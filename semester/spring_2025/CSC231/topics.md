# CSC 231 - Spring 2025 - Course Topics

## Big questions 

There are two *big questions* that the course content and activities will focus on:

* How is the *language* part of programming languages processed?
	* This material will examine the processes of compilation and interpretation, representations for specifying languages, and algorithms for recognizing language structures.
* What *styles* of programming languages exist?
	* This material will examine the utility and design of a spectrum of languages, particularly considering how features of a given language make it suitable for a particular style of problem domain


As time allows and where relevant, the following question will also be addressed: 

* What *mechanisms* do modern programming languages support?
	* This material will primarily examine a range of language design features, possible implementations of those features, and costs for supporting such features.

## Learning objectives

After successful completion of this course, students should be able to:

1. Make use of and, for low to medium complexity scenarios, design computational tools that represent/recognize language structures
2. Justify the design of a programming language feature based on the context of its use
3. Simulate the mechanisms behind the implementations of programming language features
4. Read and interpret solutions to non-trivial problems written in various styles of programming languages
5. Write solutions to low complexity problems using various styles of programming languages
6. Provide written interpretations of code and analyses for other computer scientists to consume
7. Design appropriate tests for developed solutions

## Topics
Topics covered in the course are expected to include, but are not limited to, the following. The topics are not necessarily in order of presentation during the course.
At the end of the semester, this list will be updated to reflect the actual course coverage.

* Language recognizers
  * Finite state machines
  * Finite state machine design
  * Non-deterministic finite state machines
  * Finite state machine implementations
  * LR(0) parsing
* Language generators
  * Regular expressions
  * Extended regular expression syntax
  * Grammars
  * Grammar-based inductive data structure definitions
* Programming paradigms
  * Event driven programming
  * Reactive programming
  * Functional programming
    * Higher order functions
  * Logical programming
* Program correctness
  * Formal methods
  * Ethical issues relating to programming languages
